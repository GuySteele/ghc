\documentclass[parskip=half]{scrartcl}

\usepackage[T1]{fontenc}
\usepackage[safe]{tipa} % for \textlambda
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{etex}
\usepackage{stmaryrd}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{mathtools}
%\usepackage[amsmath,thmmarks]{ntheorem}
\usepackage[numbers]{natbib}
\usepackage{mathpazo}
% Causes problems with MikTeX
%\usepackage{microtype}
\usepackage{booktabs}
\usepackage{mathpartir}
\usepackage{upgreek}
\usepackage{enumerate}
\usepackage{paralist}
\usepackage{textcomp}
\usepackage{xcolor}

\usepackage{hyperref}

\urlstyle{sf}
\makeatletter
% Inspired by http://anti.teamidiot.de/nei/2009/09/latex_url_slash_spacingkerning/
% but slightly less kern and shorter underscore
\let\UrlSpecialsOld\UrlSpecials
\def\UrlSpecials{\UrlSpecialsOld\do\/{\Url@slash}\do\_{\Url@underscore}}%
\def\Url@slash{\@ifnextchar/{\kern-.11em\mathchar47\kern-.2em}%
   {\kern-.0em\mathchar47\kern-.08em\penalty\UrlBigBreakPenalty}}
\def\Url@underscore{\nfss@text{\leavevmode \kern.06em\vbox{\hrule\@width.3em}}}
\makeatother

%\theorembodyfont{}
%\newtheorem{theorem}{Theorem}
%\newtheorem{lemma}[theorem]{Lemma}
%\theoremstyle{nonumberplain}
%\theoremheaderfont{\scshape}
%\theoremsymbol{\ensuremath{\blacksquare}}
%\theoremseparator{.}
%\newtheorem{proof}{Proof}

\newcommand{\TODO}[1]{\textcolor{red}{TODO: #1}}

\usepackage{listings}
\newcommand{\li}{\lstinline[style=Haskell]}
\lstnewenvironment{haskell}{\lstset{style=Haskell}}{}
\lstdefinestyle{Haskell}{language=Haskell
        ,columns=flexible
	,basewidth={.365em}
	,keepspaces=True
        ,texcl=true
%        ,escapechar=!
        ,basicstyle=\sffamily
        ,stringstyle=\itshape
        ,showstringspaces=false
        ,literate={->}{$\,\to\,$}2
                  {<-}{$\,\leftarrow\,$}2
                  {=>}{$\,\Rightarrow\,$}2
                  {â†’}{$\,\to\,$}2
%                  {\\}{\textlambda}1
                  {>>}{{>>}\hspace{-1pt}}2
%                  {+}{{$+$}}1
                  {[]}{[\,]\ }1
%                  {--}{{---\ }}1
                  {++}{{$+\!\!+$}}1
%                 {\ .}{{$\,\circ\,$}}2
                  {\ .\ }{{$\,\circ\,$}}2
                  {~}{{$\sim$}}1 % hack
                  {|>}{{$\triangleright$}}1 % hack
	,keywords={%
	    case,class,data,default,deriving,do,else,%
	    foreign,if,import,in,infix,infixl,infixr,instance,%
	    let,forall,letrec,module,newtype,role,of,then,type,where,\_,%
	}
        }

\newcommand{\sIde}{\text{Ide}}
\newcommand{\sExp}{\text{Exp}}
\newcommand{\sEnv}{\text{Env}}

\newcommand{\sem}[2]{\llbracket #1\rrbracket #2}

\newcommand{\sApp}[2]{#1\,#2}
\newcommand{\sLam}[2]{\text{\textlambda} #1.\, #2}
\newcommand{\sCase}[4]{\text{\textsf{case}}\ #1\  \textsf{as}\ #2\ \textsf{of}\ \{#3 \rightarrow #4\}_{i=1}^n}
\newcommand{\sLet}[3]{\text{\textsf{let}}\ \{#1 = #2\}_{i=1}^n\ \text{\textsf{in}}\ #3}

\newcommand{\both}[2]{#1\mathbin{\&}#2}


\title{Constructd Product Result Analysis -- nested}
\author{Joachim Breitner}

\begin{document}
\maketitle
% \allowdisplaybreaks[1]

\begin{abstract}
Since many years, GHC is able to optimize functions returning product types by allowing them to return multiple values. We enhance this transformation to nested products, which in turn requires a small termination analysis.

This paper describes the analysis and transformation. It can be considered an extension of \citep{cpr}.
\end{abstract}

\tableofcontents

\section{The language}

Just like in \citep{cpr}, we present the analysis with regard to a core language that does not involve type annotations, our expressions are of the form:
%
\begin{align*}
x \colon \sIde \\
e \colon \sExp &\Coloneqq x
	\mid \sLam x e
	\mid \sApp {e_1} {e_2}
	\mid \sApp C {e_1\ldots e_n} \\
&	\mid \sCase e x {\sApp {C_i} {e_{1_i}\ldots e_{n_i}}} {e_i}
	\mid \sLet {x_i} {e_i} e
\end{align*}

\section{The abstract domain}

With nested CPR, we need to know two things about a value:
\begin{itemize}
\item Does it return construct and return a data constructor, and
\item does it so for sure (and without side-effects, which are not modelled in this section).
\end{itemize}

\newcommand{\dR}{\textbf{R}}
\newcommand{\dC}{\textbf{C}}
\newcommand{\dD}{\textbf{D}}
\newcommand{\noCPR}{\bullet}
\newcommand{\dunno}[1]{#1?}
\newcommand{\conv}[1]{#1!}
\newcommand{\dLam}[1]{\sLam\bullet{#1}}
\newcommand{\dApp}[1]{\sApp{#1}\bullet}

In particular, we will need to know this about the parameters of a returned constructor. Therefore, our analysis works with a domain described by these equations:
\begin{align*}
\dR \Coloneqq{} & \bot && \text{definite divergence}\\
\mid{} &\dunno{\dC} && \text{potential convergence}\\
\mid{} &\conv{\dC} && \text{definite convergence}\\
\dC \Coloneqq{} & \noCPR && \text{no information about the returned value} \\
\mid{} & (\dR,\ldots, \dR) && \text{returns a constructed product}
\end{align*}
where the lattice is generated by the relations
\begin{itemize}
\item $\bot \sqsubset \dunno c$,
\item $\conv{c} \sqsubset \dunno c$,
\item $(r_1,\ldots, r_n) \sqsubset \noCPR$
\end{itemize}
and by mapping $\dunno\cdot$, $\conv\cdot$ and $(\cdot,\ldots,\cdot)$ over relations. The element $\noCPR$ is the top of the lattice \dC; $\dunno\noCPR$ the top of $\dR$. Neither lattice has a bottom element, the use of $\bot$ is justified as it denotes definite divergence, and because it is used to initialize the fixed point iterations.

In slight abuse of notation, $\conv{\cdot} \colon \dR \to\dR$ sets the convergence flag
\begin{align*}
\conv{\bot} &= \bot \\
\conv{\conv{c}} &= \conv{c} \\
\conv{\dunno{c}} &= \conv{c}
\end{align*}

The operation $\both{\cdot}{\cdot} \colon \dR \to \dR \to \dR$ adjusts the termination information of the first value based on that of the second:
\begin{align*}
\both{\bot}r &= \bot \\
\both r{\bot} &= \bot \\
\both{\conv{c_1}}{\conv{c_2}} &= \conv{c_1} \\
\both{\conv{c_1}}{\dunno{c_2}} &= \dunno{c_1} \\
\both{\dunno{c_1}}{\conv{c_2}} &= \dunno{c_1} \\
\both{\dunno{c_1}}{\dunno{c_2}} &= \dunno{c_1}
\end{align*}

There is a projection operation $\pi_i \colon \dC \to \dR$, defined by
\begin{align*}
\pi_i(r_1,\ldots,r_n) &=
\begin{cases}
\pi_i (r) & \text{for $1 \le i \le n$}\\
\dunno\noCPR & \text{otherwise}
\end{cases}\\
\pi_i(\noCPR) &= \dunno\noCPR,
\end{align*}
and lifted to $\dR$ by
\begin{align*}
\pi_i(\bot) &= \dunno\noCPR\\
\pi_i(\dunno c) &= \pi_i(c) \\
\pi_i(\conv c) &= \pi_i(c).
\end{align*}

Furthermore, for functions, we additionally need to know their arity. Conceptually, this yields the product domain $\dD=(\mathbb N, \dR)$, where $\mathbb N$ is descretely ordered, but in analogy to \citep{cpr}, we write
\begin{align*}
\dD \Coloneqq \dR \mid \dLam\dD.
\end{align*}
Decreasing the arity of $d$ is written $\dApp d$, in analogy to function application, and defined by
\begin{align*}
\dApp{(\dLam d)} = d\\
\dApp{r} = \dunno\noCPR
\end{align*}
The projection operation is also lifted to $\dD$:
\begin{align*}
\pi_i(\dLam{d}) &= \dunno\noCPR\\
\pi_i(r) &= \pi_i(r) \\
\end{align*}


An environment is a function from identifiers to abstract values:
\begin{align*}
\rho \colon \sExp = \sIde \to \dD.
\end{align*}

\section{The analysis}

So our analysis is a function $\sem{\cdot}\cdot \colon \sExp \to \sEnv \to \dD$, defined as follows:
%
\newcommand{\upd}[3]{#1[#2 \mapsto #3]}
%
\begin{align*}
\sem{x}\rho &= \sApp \rho x \\
\sem{\sLam x e}\rho &= \sem e{\upd\rho x{\dunno\noCPR}} \\
\sem{\sApp {e_1} {e_2}}\rho &= \dApp{(\sem{e_1}\rho)} \\
\sem{\sApp C {e_1\ldots e_n}}\rho &= \conv{(\sem{e_1}\rho, \ldots, \sem{e_n}\rho)} \\
\sem{\sLet {x_i}{e_i} e}\rho &= \sem{e}({\mu \rho'. \upd\rho{x_i}{\sem{e_i}{\rho'}}_{i=1}^n})\\
\sem{\sCase e x {\sApp {C_i} {e_{1_i}\ldots e_{n_i}}} {e_i}}\rho
	&= \both{\left(
	     \bigsqcup_{i=1}^n \sem{e_i}{
		\upd{\upd\rho{x_j}{ \pi_j(\sem{e}\rho) }_{j=1}^{n_i}}}
		    {x}{\conv{\sem{e}\rho}}
	   \right)}{\sem{e}\rho}
\end{align*}

The fixed-point operator $\mu \rho'. f \rho'$ is a bit peculiar: It initializes the environment by mapping each of $x_i$, $i=1,\ldots,n$, to $\bot$, and then iterating $f$ until a fixed-point is reached. But note that $\bot$ is not the least element of $\dR$ (and it must not be, as otherwise $\bot \sqcup \conv c = \conv c$ would hold erroneously), so the elements of the iteration do not form a chain, and the fixed point is not simply the least upper bound of all the iterations. \TODO{Is that a problem?}


\end{document}
